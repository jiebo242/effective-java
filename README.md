# effective-java
effective-java[第三版]书中的代码示例,JDK版本为1.8.0_181
# 作者提供的本书代码示例
https://github.com/jbloch/effective-java-3e-source-code.git
# 目录结构
| chapter | item | explanation |
|:-:|:-:|:-:|
| 02 |    | 创建和销毁对象 |
|    | 02 | 实体类多个参数的情况下，推荐使用构建器Build |
|    | 03 | Singleton单例的多种实现方式：饥饿方式、懒加载方式、枚举方式、静态内部类方式(饥饿+懒加载的融合) |
|    | 05 | 推荐依赖注入的方式来引入资源，有诸多好处 |
|    | 06 | 避免创建不必要的对象，但是要看是什么类型的对象，创建新的还是复用已有的是要比较各方面代价后的一个结果 |
|    | 07 | 及时将过期的引用置为null，但并不是每个对象都要手动清除引用，大部分还是交给GC来做，文中主要说明了内存泄漏的3个主要来源 |
|    | 09 | 针对需手工关闭的资源，JDK1.7之后有了一种新的写法，不用再手动close资源了 |
| 03 |    | 所有对象都通用的方法 |
|    | 10 | equals方法的原则和写法，推荐使用lombok或者AutoValue来自动生成 |
|    | 11 | hashCode方法的重写应该是和equals方法一起的，推荐使用lombok或者AutoValue来自动生成 |
|    | 13 | clone方法尽量不要重写，建议使用拷贝构造器或拷贝工厂方法来替代，写clone方法时务必注意引用类型域的层级clone |
|    | 14 | 如果类的对象要是有序的，提供3种方式来实现排序逻辑 |
| 04 |    | 类和接口编写时的注意事项 |
|    | 15 | 使类和成员的可访问性最小化：private-default-protected-public |
|    | 16 | 公有类的域不应该直接暴露数据域的访问，而是应该提高相应域的操作方法，比如：域设置为private，然后提供get/set方法 |
|    | 17 | 使类和成员的可变性最小化：final修饰 |
|    | 18 | 复合优先于继承，因为继承是打破了封装性的，让程序变的脆弱 |
|    | 19 | 必要时如何编写可继承类：①专门为了继承而设计的②提供很好的说明文档(相当于永久承诺) |
|    | 20 | 接口优于抽象类：①接口有多种好处②对接口提供一个抽象的骨架实现类，可以结合接口和抽象类的优点  |
|    | 21 | 为后代设计接口时，需要考虑的地方 |
|    | 22 | 接口只用于定义类型，不应该用于定义和导出常量，同时提供了几种定义常量的方案 |
|    | 23 | 标签类很少适用，尽量拆分成类层次的方式 |
|    | 24 | 4种嵌套类的声明方式及常见的适用场景 |
|    | 25 | 一个java文件不要定义多个顶级类，这个在IDEA下不存在，会校验出来的 |
| 05 |    | 泛型的使用 |
|    | 26 | 避免使用原生态类型，因为它不是类型安全的，运行时会有异常 |
|    | 27 | 通过注解@SuppressWarnings("unchecked")消除非受检的警告，前提是你确保它是类型安全的 |
|    | 28 | 泛型数组在使用时如果出现编译错误或警告，优先考虑用泛型列表替换数组 |
|    | 29 | 泛型类的编写及注意规范 |
|    | 30 | 泛型方法的编写及注意规范  |
|    | 31 | API定义时，考虑使用通配符来提高灵活性，并明白什么场景下使用通配符及如何使用 |
|    | 32 | 泛型和可变参数是不合的，并用泛型和可变参数的注意事项以及替代方案 |
|    | 33 | 如何编写类型安全的异构容器，主要是通过类型令牌 |
| 06 |    | 枚举和注解的使用 |
|    | 34 | 当需要定义一组固定常量时，enum比int常量有更多的好处：可读性、安全性等 |
|    | 35 | 尽量不使用enum自带的序数值ordinal，而是给枚举添加一个域来记录 |
|    | 36 | 用EnumSet代替位域，但是平常也没啥场景要使用位域 |
|    | 37 | 当根据Enum来进行分类的时候，不要使用enum[]或list<enum>并且用enum的序数ordinal来作为索引，而是应该使用EnumMap |
|    | 38 | 因为枚举无法继承扩展，所以这里作者建议同一类的enum都implement同一个接口来模拟枚举的扩展  |
|    | 39 | 通过编写一个@Test注解，来说明注解的写法和用法 |
|    | 40 | 覆盖方法记得使用@Override注解 |
|    | 41 | 论述标记接口和标记注解的优缺点，及使用的场景 |
| 07 |    | Lambda和Stream的使用 |
|    | 42 | Lambda、方法引用都是匿名类的一个升级方案，都是为了提供函数对象的，最终的目的是函数编程 |
|    | 43 | 提供函数对象：方法引用>Lambda>匿名类 |
|    | 44 | 使用函数接口时，优先使用java.util.function下预定义的，本章对下面的接口做了一个分类说明，方便记忆 |
|    | 45 | Stream的写法，以及和迭代写法的对比和选用场景 |
|    | 46 | 实在看不懂，后续专题研究 |
|    | 47 | 实在看不懂，后续专题研究 |
|    | 48 | 实在看不懂，后续专题研究 |